记一些零散的数据库内容

#### 最左原则

在联合索引中，使用最左原则

#### 关于建索引

索引不是越多越好，大量索引会导致增删操作效率下降，同时对磁盘的消耗也会很大，重复率高的不用建索引，

#### B+ 树存储索引

多叉树，每个节点存储多个元素（默认16k），如果使用整型自增主键，<u>叶子结点会有下一区间的指针，在应对范围查找时，很容易。同时也不容易出现调整树结构的情况</u>

根节点常驻内存，之后的查询通过 IO

#### Hash 存储

精准定位很快，但是<u>无法进行**范围查找**</u>

就是等值查询的时候，使用 hash 的索引

#### innodb 

支持事务

存储的文件只有两个

InnoDB是**聚集索引**，<u>使用B+Tree作为索引结构</u>，数据文件是和（主键）索引绑在一起的（表数据文件本身就是按B+Tree组织的一个索引结构），必须要有主键，通过主键索引效率很高。但是<u>辅助索引需要两次查询</u>，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。

InnoDB 支持行锁，是<u>实现在索引上的</u>，而不是锁在物理行记录上。潜台词是，<u>如果访问没有命中索引，也无法使用行锁，将要退化为表锁</u>。

支持崩溃后恢复

#### SQL 调优方法

1. 避免全表扫描，在 **where** 及 **order by** 涉及的列上建立索引
2. **where 子句**中会**全表扫描**的操作
   1. 避免进行 ~~null 的判断~~，**解决**：<u>使用 0 值代表 null</u>
   2. 避免~~表达式、函数操作~~
3. 避免使用 ~~!= 、>、< 操作符~~
4. 避免使用 ~~or 连接条件~~，如果另一个条件不是索引，就会放弃使用索引
   **解决**：<u>使用 union all</u>
5. 避免~~模糊查询 like~~，尽量把模糊的位置放后面
6. 索引是联合索引，应当将该索引的第一个字段作为条件才能保证使用索引
7. 慎用 in 和 not in，可以使用 exist 代替

#### sql调优的整段描述与思路

首先，表需要主键，innodb 会创建主键为聚簇索引，它的主键和数据是绑定在一行，而且用 explain 查询分析时，可以看到它的 type 是 const 级别，是非常高的级别。

如果有主键了，查询很慢，就要看是否建立了相应索引，就是在 where 子句的条件，还有 order by，join 等这些建立索引，同时要符合最左匹配原则，将字段排序。

然后就是上面的 sql 语句调优

**再来一个**

1. 运行 sql，使用 explain
2. 添加索引，如果因为一些原因没有走索引，可以用 force index 强制走索引，比较是否更快，然后进行选择
3. 如果存在回表的情况，可以使用覆盖索引避免回表
4. 根据最左原则，应当按照联合索引定义的字段顺序写 sql
5. 如果数据是唯一的，就建唯一索引，可以减少查询时间

#### 数据库事务和 MVCC 的关系

版本连：在聚集索引中，有两个隐藏列 trx_id, roll_pointer

读未提交：无视图概念，都是返回最新的

读已提交：每次读取生成不同的 read view

可重复度：第一次生成一个 read view

序列化：串行执行

#### 索引下推

like 'hello%’and age >10 检索，MySQL5.6版本之前，会对匹配的数据进行回表查询。5.6版本后，会先过滤掉age<10的数据，再进行回表查询，减少回表率，提升检索速度

#### explain 执行计划

| id   | select_type | table   | type | possible_keys |
| ---- | ----------- | ------- | ---- | ------------- |
| 2    | DERIVED     | TBL_EMP | REF  | FK_DEPT_ID    |

| KEY        | KEY_LEN | REF   | ROWS | EXTRA       |
| :--------- | ------- | ----- | ---- | ----------- |
| FK_DEPT_ID | 5       | CONST | 3    | USING INDEX |

###### **2）  select_type**

查询的类型,主要用于区别普通查询,联合查询,子查询等复杂查询

* simple:简单的select查询,查询中不包含子查询或union查询
* primary:查询中若包含任何复杂的子部分,最外层查询则被标记为primary
* subquery 在select 或where 列表中包含了子查询
* derived 在from列表中包含的子查询被标记为derived,mysql会递归这些子查询,把结果放在临时表里
* union 做第二个select出现在union之后,则被标记为union,若union包含在from子句的子查询中,外层select将被标记为derived
* union result 从union表获取结果的select

###### 4）  **type**

查询类型从最好到最差依次是:==system>const>eq_ref>ref>range>index>All==,一般情况下,得至少保证达到range级别,最好能达到ref

**const**：表示通过索引一次就找到了，const 即常亮，<u>如果主键置于 where 中</u>，mysql 就能将该查询转换为一个 常亮

eq_ref:唯一性索引扫描,对于每个索引键,表中只有一条记录与之匹配,常见于主键或唯一索引扫描

**ref**:非唯一性索引扫描,返回匹配某个单独值的行,它可能会找到多个符合条件的行,所以他应该属于查找和扫描的混合体

range:只检索给定范围的行,使用一个索引来选择行,如where语句中出现了between,<,>,in等查询,这种范围扫描索引比全表扫描要好，因为它只需要开始于索引的某一点，而结束于另一点，不用扫描全部索引。

**index**:index类型只遍历索引树,这通常比All快,因为索引文件通常比数据文件小,index是从索引中读取,all从硬盘中读取

**all**:全表扫描,是最差的一种查询类型

###### 5）  **possible_keys**

显示可能应用在这张表中的索引,一个或多个,查询到的索引不一定是真正被用到的

###### 6）  **key**

实际使用的索引,如果为null,则没有使用索引,因此会出现possible_keys列有可能被用到的索引,但是key列为null,表示实际没用索引。

**key_len**
索引长度

###### 8）  **ref**

显示索引的哪一列被使用了,如果可能的话是一个常数,哪些列或常量被用于查找索引列上的值

###### 9）  **rows**

根据表统计信息及索引选用情况,大只估算出找到所需的记录所需要读取的行数



#### 锁

全局锁

表锁：读锁不互斥，写锁互斥

行锁：

- 需要的时候才加，并且不立刻释放，等事务结束才释放，**两阶段锁协议**
- 死锁：死锁机制，事务回滚
- 热点行
  - 控制并发度
  - 分治
  - 间歇锁
  - 读写锁 